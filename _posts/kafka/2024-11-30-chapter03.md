---
title: Chapter 03. 카프카 프로듀서
date: 2024-11-30 13:10:00 +0900
categories: [카프카 핵심가이드]
tags: [카프카 핵심가이드]
---

## **1. 프로듀서 개요 📌**
- **프로듀서의 역할**: 데이터를 카프카 브로커에 전송
- **주요 개념**
    - **`ProducerRecord`**: 카프카에 메시지를 작성하기 위한 객체
    - **`KafkaProducer`**: 프로듀서를 구성하고 브로커와 통신을 담당
    - **파티션**: 메시지가 저장되는 브로커의 논리적 단위
- **사용 예시**
    - 신용카드 트랜잭션 처리
    - 웹사이트 조회 로그 전송 등

---

## **2. 프로듀서 기본 구조 📌**
- **`ProducerRecord`** 객체를 생성하며 시작
    - **토픽**과 **밸류**는 필수, 키와 파티션은 선택적으로 지정
- 메시지 전송 과정
    1. **직렬화**: 키와 값을 바이트 배열로 변환
    2. **파티셔닝**: 키가 있으면 해싱, 없으면 Round Robin 방식으로 파티션 결정
    3. **배치 추가**: 직렬화된 메시지를 레코드 배치에 추가
    4. **전송**: 백그라운드 스레드가 레코드 배치를 브로커로 전송

---

## **3. 필수 설정 ⚙️**
- **`bootstrap.servers`**
    - 브로커의 `host:port` 목록을 지정
    - 최소 2개 이상의 브로커를 설정하여 연결 안정성을 높임
- **`key.serializer`, `value.serializer`**
    - 메시지 키와 값을 직렬화하기 위한 설정
    - 일반적으로 `StringSerializer` 또는 `ByteArraySerializer`를 사용함

---

## **4. 메시지 전송 방식 ✉️**
- **파이어 앤 포겟**
    - 메시지를 전송한 뒤 성공 여부를 확인하지 않음
    - 처리 속도가 빠르지만 메시지 손실 가능성이 있음
- **동기 전송**
    - `send()` 호출 후 `get()`으로 결과를 반환받음
    - 전송 결과를 기다리는 동안 스레드가 블록됨
    - `Future` 객체를 활용하여 비동기 결과를 동기적으로 처리
- **비동기 전송**
    - 콜백 함수를 사용해 메시지 전송 성공 또는 실패를 처리
    - 전송 결과에 따라 자동으로 콜백이 호출됨
    - 네트워크 지연을 최소화하며 효율적인 방식임

---

## **5. 주요 프로듀서 설정 ⚙️**
- **`acks` (Acknowledgment Level)**
    - 메시지 전송 신뢰성을 설정
        - `acks=0`: 최소 전송 보장 At Most Once
        - `acks=1`: 중복 가능성을 허용하는 At Least Once
        - `acks=all`: 모든 레플리카의 확인을 요구하는 Exactly Once
- **`linger.ms`**
    - 배치 전송 전 대기 시간을 설정하여 효율성을 높임
- **`buffer.memory`**
    - 전송 대기 중인 메시지를 저장할 버퍼 크기
- **`compression.type`**
    - 메시지 압축 방식 설정 (`gzip`, `snappy`, `lz4`)
- **`enable.idempotence`**
    - 메시지를 정확히 한 번만 전송하도록 보장
    - 메시지 순서와 중복 방지를 위한 필수 설정

---

## **6. 시리얼라이저와 스키마 📃**
- **기본 시리얼라이저**
    - `StringSerializer`, `ByteArraySerializer` 등 제공
- **범용 직렬화 라이브러리**
    - Apache Avro와 같은 라이브러리 권장
    - 데이터 타입과 스키마를 유지하면서 효율적인 직렬화 지원
    - 스키마 변경 시 기존 컨슈머와의 호환성 유지 가능

---

## **7. 파티션과 접착성 처리 🔐**
- **파티션 할당 방식**
    - 키 값이 존재하면 해싱하여 파티션 결정
    - 키 값이 없으면 Round Robin 방식으로 파티션 할당
- **접착성 처리**
    - 키 값이 없는 메시지들을 같은 배치로 묶어 전송하여 효율성을 높임

---

## **8. 레코드 헤더 📃**
- 메시지의 키와 값 외에 추가적인 메타데이터를 포함할 수 있음
- 메시지를 파싱하지 않고도 헤더 정보를 활용해 메시지를 해석 가능

---

## **9. 인터셉터 📝**
- **`onSend`**
    - 메시지가 브로커로 전송되기 전에 호출되며, 메시지 내용을 수정할 수 있음
- **`onAcknowledgement`**
    - 브로커 응답을 수신한 후 호출되며, 메시지를 읽기 전용으로 처리

---

## **10. 쿼터 및 쓰로틀링 🤦‍♀️**
- **브로커 처리량 초과 시 발생하는 문제**
    - 클라이언트 버퍼 메모리가 부족하면 `send()` 호출이 블록됨
    - `delivery.timeout.ms`를 초과하면 메시지가 무효화됨
- **해결 방법**
    - 브로커와 프로듀서 간 병목현상을 모니터링하며 설정값 조정 필요
